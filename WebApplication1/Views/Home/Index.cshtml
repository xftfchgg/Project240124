@{
    ViewData["Title"] = "Home Page";
}

<div class="text-center">
    <h1 class="display-4">Welcome</h1>
    <p>Learn about <a href="https://learn.microsoft.com/aspnet/core">building Web apps with ASP.NET Core</a>.</p>
</div>
<ul class="ul">
    <li>tom,3,35000</li>
</ul>


@section scripts{
    <script>
        const theUl = document.querySelector(".ul")
        const emps = [{ "name": "Tom", "workYears": 3, "salary": 35000 },
        { "name": "Jack", "workYears": 5, "salary": 40000 },
        { "name": "Mary", "workYears": 7, "salary": 45000 }];

        const datas = emps.map(employee => {
            const { name, workYears, salary } = employee //解構賦值
            return (
                `
                    <li>${ name },${ workYears },${ salary } </li>
                    `
            )
        })
        theUl.innerHTML = datas.join("");






        // //JSON資料讀取
        // for (let i = 0, max = emps.length; i < max; i++) {
        //     console.log(emp[i].name);
        //     console.log(emp[i].workYears);
        //     console.log(emp[i].salary);
        // }



        //Array =>方法
        // emps.forEach((emp)=>{

        //         // console.log(emp.name);
        //         // console.log(emp.workYears);
        //         // console.log(emp.salary);

        //     const theLi = document.createElement("li"); //<li>
        //     theLi.appendChild(`${emp.name},${emp.workYears},${emp.salary}`)
        //     theUl.appendChild(theLi);
        // })
        


        // //建立Promise
        // function show(data) {
        //     const promise = new Promise((resolve, reject) => {
        //         setTimeout(() => { resolve(data) }, 1000)
        //     });
        //     return promise;
        // }





        // //async await => 用同步的程式語法結構來完成非同步的效果
        // // async function abc() {
        // //     let data = await show ("A")
        // // }

        // //IIFE (立即調用函式)
        // (async() => {
        //     let data = await show("A");
        //     console.log(data);
        //     data = await show("B");
        //     console.log(data);
        //     data = await show("C");
        //     console.log(data);
        // })


        //使用Promise
        // console.log(show("A"));
        // show("A")
        //     .then((data) => {
        //         console.log(data)
        //         return show("B")
        //     })
        //     .then((data) => {
        //         console.log(data)
        //         return show("C")
        //     })
        //     .then((data) => {
        //         console.log(data)
        //     });






        // //建立一個Promise物件
        // const promise = new Promise((resolve, reject) => {
        //     // 這裡就是原來的非同步(async)、回呼(callback)…的程式
        //     const num = Math.random() > 0.5 ? 1 : 0;
        //     if (num) {
        //         resolve("沒問題!");
        //           }
        //     else {
        //         reject("錯誤發生了!!");
        //           }
        // });

        // //使用Promise
        // promise
        //     //成功時執行 
        //     .then((data) => {
        //         console.log(data);
        //     })
        //     //失敗時執行
        //     .catch((err) => {
        //         console.log(err);
        //     })
        //     //無論如何都會執行
        //     .finally(() => {
        //         console.log("end");
        //     })




        // setTimeout(function () {
        //     console.log('A');
        // }, 1000);
        // setTimeout(function () {
        //     console.log('B');
        // }, 1000);
        // setTimeout(function () {
        //     console.log('C');
        // }, 1000);

        // setTimeout(function () {
        //     console.log('A');
        // }, 3000);
        // setTimeout(function () {
        //     console.log('B');
        // }, 2000);
        // setTimeout(function () {
        //     console.log('C');
        // }, 1000);




    </script>
}


